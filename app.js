'use strict';

var platform = require('./platform'),
	_get     = require('lodash.get'),
	_isNaN   = require('lodash.isnan'),
	inRange  = require('lodash.inrange'),
	forEach  = require('lodash.foreach'),
	isEmpty  = require('lodash.isempty'),
	isNumber = require('lodash.isnumber'),
	isString = require('lodash.isstring'),
	googleMapsClient, geocodingType, parseAddress;

var _handleException = function (requestId, error) {
	platform.sendResult(requestId, null);
	platform.handleException(error);
};

/**
 * Emitted when device data is received.
 * @param {string} requestId The request id generated by the platform for this service request.
 * @param {object} data The data coming from the device represented as JSON Object.
 */
platform.on('data', function (requestId, data) {
	if (geocodingType === 'Forward') {
		if (!isString(data.address)) return _handleException(requestId, new Error('Invalid address.'));

		var geocodeParams = {
			address: data.address,
			language: 'en'
		};

		googleMapsClient.geocode(geocodeParams, function (error, results) {
			if (error)
				_handleException(requestId, error);
			else if (results.status === 'ZERO_RESULTS')
				platform.sendResult(requestId, null);
			else if (results.status !== 'OK')
				_handleException(requestId, new Error(results.error_message));
			else {
				var result = {
					lat: _get(results, 'results[0].geometry.location.lat'),
					lng: _get(results, 'results[0].geometry.location.lng')
				};

				platform.sendResult(requestId, JSON.stringify(result));

				platform.log(JSON.stringify({
					title: 'Google Geocoding Service Result',
					input: data.address,
					result: result
				}));
			}
		});
	}
	else {
		if (_isNaN(data.lat) || !isNumber(data.lat) || !inRange(data.lat, -90, 90) ||
			_isNaN(data.lng) || !isNumber(data.lng) || !inRange(data.lng, -180, 180)) {

			_handleException(requestId, new Error('Latitude (lat) and Longitude (lng) are not valid. lat: ' + data.lat + ' lng:' + data.lng));
		}
		else {
			var reverseGeocodeParams = {
				latlng: data.lat + ',' + data.lng,
				language: 'en'
			};

			googleMapsClient.reverseGeocode(reverseGeocodeParams, function (error, results) {
				if (error)
					_handleException(requestId, error);
				else if (results.status === 'ZERO_RESULTS')
					platform.sendResult(requestId, null);
				else if (results.status !== 'OK')
					_handleException(requestId, new Error(results.error_message));
				else {
					var result;

					if (parseAddress) {
						result = {
							full_address: _get(results, 'results[0].formatted_address'),
							street_address: '',
							city: '',
							state: '',
							postal_code: '',
							country: ''
						};

						forEach(_get(results, 'results[0].address_components'), function (component) {
							switch (component.types[0]) {
								case 'postal_code':
									result.postal_code = component.short_name;
									break;
								case 'street_address':
									result.street_address = result.street_address.concat(component.short_name);
									break;
								case 'route':
									result.street_address = (isEmpty(result.street_address)) ? result.street_address.concat(component.short_name) : result.street_address.concat(' ' + component.short_name);
									break;
								case 'neighborhood':
									result.street_address = (isEmpty(result.street_address)) ? result.street_address.concat(component.short_name) : result.street_address.concat(' ' + component.short_name);
									break;
								case 'administrative_area_level_1':
									result.state = component.short_name;
									break;
								case 'locality':
									result.city = component.short_name;
									break;
								case 'ward':
									result.city = component.short_name;
									break;
								case 'country':
									result.country = component.short_name;
									break;
							}
						});
					}
					else
						result = _get(results, 'results[0].formatted_address');

					platform.sendResult(requestId, JSON.stringify({
						address: result
					}));

					platform.log(JSON.stringify({
						title: 'Google Geocoding Service Result',
						input: {
							lat: data.lat,
							lng: data.lng
						},
						result: result
					}));
				}
			});
		}
	}
});

/*
 * Event to listen to in order to gracefully release all resources bound to this service.
 */
platform.on('close', function () {
	platform.notifyClose(); // No resources to clean up. Just notify the platform.
});

/*
 * Listen for the ready event.
 */
platform.once('ready', function (options) {
	var config     = require('./config.json'),
		GoogleMaps = require('googlemaps');

	parseAddress = (options.parse_address === true);

	var googleMapsClientConfig = {
		stagger_time: 1000, // for elevationPath
		encode_polylines: false,
		secure: true // use https
	};

	if (options.clientid) {
		googleMapsClientConfig.google_client_id = options.client_id;
		googleMapsClientConfig.google_private_key = options.key;
	}
	else
		googleMapsClientConfig.key = options.key;

	geocodingType = options.geocoding_type || config.geocoding_type.default;

	googleMapsClient = new GoogleMaps(googleMapsClientConfig);

	platform.log('Google Geocoding Service Initialized.');
	platform.notifyReady();
});